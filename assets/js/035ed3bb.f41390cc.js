"use strict";(self.webpackChunkmask_docs=self.webpackChunkmask_docs||[]).push([[533],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return h}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var p=i.createContext({}),s=function(e){var t=i.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),u=s(n),h=a,m=u["".concat(p,".").concat(h)]||u[h]||c[h]||r;return n?i.createElement(m,o(o({ref:t},d),{},{components:n})):i.createElement(m,o({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=u;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<r;s++)o[s]=n[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2580:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return l},metadata:function(){return s},toc:function(){return c}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),o=["components"],l={},p="Payload version -37",s={unversionedId:"payload-format/payload-v37",id:"payload-format/payload-v37",title:"Payload version -37",description:"Status: This format has not been shipped to production yet. It might change at any time.",source:"@site/docs/payload-format/payload-v37.md",sourceDirName:"payload-format",slug:"/payload-format/payload-v37",permalink:"/docs/payload-format/payload-v37",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/payload-format/payload-v37.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"PayloadContainer",permalink:"/docs/payload-format/payload-container"},next:{title:"TypedMessage binary format",permalink:"/docs/payload-format/typed-message"}},d={},c=[{value:"Abstract",id:"abstract",level:2},{value:"Encoding",id:"encoding",level:2},{value:"<code>Payload37</code>",id:"payload37",level:3},{value:"<code>version</code> field",id:"version-field",level:4},{value:"<code>authorNetwork</code> field",id:"authornetwork-field",level:4},{value:"<code>authorID</code> field",id:"authorid-field",level:4},{value:"<code>authorPublicKeyAlgorithm</code> field",id:"authorpublickeyalgorithm-field",level:4},{value:"<code>authorPublicKey</code> field",id:"authorpublickey-field",level:4},{value:"<code>encryption</code> field",id:"encryption-field",level:4},{value:"<code>PublicEncrypted</code>",id:"publicencrypted",level:5},{value:"<code>AES_KEY</code>",id:"aes_key",level:6},{value:"<code>iv</code> field",id:"iv-field",level:6},{value:"<code>PeerToPeerEncrypted</code>",id:"peertopeerencrypted",level:5},{value:"<code>ownerAESKeyEncrypted</code> field",id:"owneraeskeyencrypted-field",level:6},{value:"<code>authorEphemeralPublicKey</code> field",id:"authorephemeralpublickey-field",level:6},{value:"<code>data</code> field",id:"data-field",level:4},{value:"References",id:"references",level:2},{value:"Next step",id:"next-step",level:2},{value:"FAQ",id:"faq",level:2},{value:"Why the version number is negative?",id:"why-the-version-number-is-negative",level:3}],u={toc:c};function h(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"payload-version--37"},"Payload version -37"),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Status: This format has not been shipped to production yet. It might change at any time.")),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"This is a binary format that is used to represent an encrypted message in the Mask Network."),(0,r.kt)("p",null,"The implementor SHOULD implement a tolerate parser for the payload."),(0,r.kt)("h2",{id:"encoding"},"Encoding"),(0,r.kt)("p",null,"To avoid reinvention of a new binary format that is hard to parse/generate, this specification chooses to represent data in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/msgpack/msgpack/blob/master/spec.md"},"MessagePack")," binary format."),(0,r.kt)("p",null,"Type ",(0,r.kt)("inlineCode",{parentName:"p"},"Integer"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Float"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Boolean"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Binary"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Array")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"Map")," are defined in the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/msgpack/msgpack/blob/master/spec.md"},"msgpack specification"),". Other type defined in this RFC is written in the TypeScript syntax."),(0,r.kt)("p",null,"To avoid encoding field names into the binary (which is space-wasting), this RFC chooses to use a tuple (represented by ",(0,r.kt)("inlineCode",{parentName:"p"},"Array")," in MessagePack), in which the order of the fields represented its meaning."),(0,r.kt)("p",null,"In extra, we define the following helper types:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type Number = Integer | Float\ntype Any = Integer | Nil | Boolean | Float | String | Binary | Array<Any> | Map\n")),(0,r.kt)("p",null,"In this specification, any form of MessagePack extension (like a timestamp) is NOT used. An implementation MAY treat data including extensions as invalid."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"Array")," in this specification is used as ",(0,r.kt)("inlineCode",{parentName:"p"},"Tuple")," with an arbitrary size, which means items in the Array don't have to be the same type."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"e.g. both ",(0,r.kt)("inlineCode",{parentName:"p"},'[1, "string"]')," and ",(0,r.kt)("inlineCode",{parentName:"p"},'["string", 1]')," are valid ",(0,r.kt)("inlineCode",{parentName:"p"},"Array"),"s that has the type ",(0,r.kt)("inlineCode",{parentName:"p"},"Array<String | Integer>"),".\nBut if the order is meaningful, the type should be ",(0,r.kt)("inlineCode",{parentName:"p"},"[Integer, String]"),".")),(0,r.kt)("p",null,"All Tuple in this specification MUST be treated as non-fixed length. This means ",(0,r.kt)("inlineCode",{parentName:"p"},'[1, "string", true]')," is valid when ",(0,r.kt)("inlineCode",{parentName:"p"},"[Integer, String]")," is required. An implementation MUST NOT fail due to the extra item unless especially specified."),(0,r.kt)("h3",{id:"payload37"},(0,r.kt)("inlineCode",{parentName:"h3"},"Payload37")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type PayloadAlpha37 = [\n  version: Integer,\n  authorNetwork: String | SocialNetworkEnum | Nil,\n  authorID: String | Nil,\n  authorPublicKeyAlgorithm: String | PublicKeyAlgorithmEnum,\n  authorPublicKey: Binary | Nil,\n  encryption: Encryption,\n  data: Binary,\n]\nenum SocialNetworkEnum {\n  Facebook = 0,\n  Twitter = 1,\n  Instagram = 2,\n  Minds = 3,\n}\nenum PublicKeyAlgorithmEnum {\n  ed25519 = 0,\n  secp256p1 = 1, // P-256\n  secp256k1 = 2, // K-256\n}\n")),(0,r.kt)("h4",{id:"version-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"version")," field"),(0,r.kt)("p",null,"This field represents the format version."),(0,r.kt)("p",null,"The first and the current binary version is ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),"."),(0,r.kt)("h4",{id:"authornetwork-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"authorNetwork")," field"),(0,r.kt)("p",null,"This field represents the social network that the author of this payload belongs to."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"SocialNetworkEnum"),", it represents a SocialNetwork that is supported by the Mask Network."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", it represents a SocialNetwork cannot be expressed within the enum. e.g. A decentralized SNS like Mastodon."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),", it represents no information is available (due to software defeat or user choice to opt out)."),(0,r.kt)("h4",{id:"authorid-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"authorID")," field"),(0,r.kt)("p",null,"This field represents the identifiable ID of the author of this payload ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),"."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),", it represents no information is available (due to software defeat or user choice to opt out)."),(0,r.kt)("h4",{id:"authorpublickeyalgorithm-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"authorPublicKeyAlgorithm")," field"),(0,r.kt)("p",null,"This field represents the algorithm that the public key is using."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicKeyAlgorithmEnum"),", it represents a well-known asymmetric algorithm."),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"String"),", it represents an asymmetric algorithm that is not covered in this specification."),(0,r.kt)("p",null,"The implementation MUST NOT fail if the algorithm is not supported."),(0,r.kt)("h4",{id:"authorpublickey-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"authorPublicKey")," field"),(0,r.kt)("p",null,"This field represents the public key of the author."),(0,r.kt)("p",null,"The value is in the compressed format of the EC key."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'TODO: clarify "compressed" format')),(0,r.kt)("p",null,"When it is ",(0,r.kt)("inlineCode",{parentName:"p"},"Nil"),", it represents no information is available (due to software defeat or user choice to opt out)."),(0,r.kt)("h4",{id:"encryption-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"encryption")," field"),(0,r.kt)("p",null,"This field represents how this payload is encrypted. There are two types of encryption, ",(0,r.kt)("inlineCode",{parentName:"p"},"PublicEncrypted")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"PeerToPeerEncrypted")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type Encryption = PublicEncrypted | PeerToPeerEncrypted\nenum EncryptionKind {\n  Public = 0,\n  PeerToPeer = 1,\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Encryption")," type is a tagged Tuple (the first item is the tag)."),(0,r.kt)("h5",{id:"publicencrypted"},(0,r.kt)("inlineCode",{parentName:"h5"},"PublicEncrypted")),(0,r.kt)("p",null,"This type represents this payload is encrypted, but the AES key is shared with everyone (and encoded in the payload)."),(0,r.kt)("p",null,"This means the message is NOT privately encrypted."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type PublicEncrypted = [\n  //\n  kind: EncryptionKind.Public,\n  AES_KEY: Binary,\n  iv: Binary,\n]\n")),(0,r.kt)("h6",{id:"aes_key"},(0,r.kt)("inlineCode",{parentName:"h6"},"AES_KEY")),(0,r.kt)("p",null,"This field represents the raw AES-256-GCM key of this payload."),(0,r.kt)("h6",{id:"iv-field"},(0,r.kt)("inlineCode",{parentName:"h6"},"iv")," field"),(0,r.kt)("p",null,"This field represents the iv used to encrypt the message."),(0,r.kt)("h5",{id:"peertopeerencrypted"},(0,r.kt)("inlineCode",{parentName:"h5"},"PeerToPeerEncrypted")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"type PeerToPeerEncrypted = [\n  kind: EncryptionKind.PeerToPeer,\n  ownerAESKeyEncrypted: Binary,\n  iv: Binary,\n  authorEphemeralPublicKey: Map<PublicKeyAlgorithmEnum, Binary>,\n]\n")),(0,r.kt)("h6",{id:"owneraeskeyencrypted-field"},(0,r.kt)("inlineCode",{parentName:"h6"},"ownerAESKeyEncrypted")," field"),(0,r.kt)("p",null,"This field represents an encrypted AES key of this payload that is encrypted with the author's public key via ECDH."),(0,r.kt)("h6",{id:"authorephemeralpublickey-field"},(0,r.kt)("inlineCode",{parentName:"h6"},"authorEphemeralPublicKey")," field"),(0,r.kt)("p",null,"This field is a Map of the compressed format of the EC key."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},'TODO: clarify "compressed" format')),(0,r.kt)("p",null,"The key indicates its format."),(0,r.kt)("p",null,"The implementation MUST NOT fail when an unknown key appears."),(0,r.kt)("p",null,"The implementation MUST ignore the invalid key for the given public key format."),(0,r.kt)("p",null,"This field is used to support ephemeral encryption with different curves."),(0,r.kt)("h4",{id:"data-field"},(0,r.kt)("inlineCode",{parentName:"h4"},"data")," field"),(0,r.kt)("p",null,"This field represents the encrypted result of a ",(0,r.kt)("a",{parentName:"p",href:"/docs/payload-format/typed-message"},"TypedMessage binary format"),"."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"secp256k1: ",(0,r.kt)("a",{parentName:"li",href:"https://en.bitcoin.it/wiki/Secp256k1"},"https://en.bitcoin.it/wiki/Secp256k1")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/msgpack/msgpack/blob/master/spec.md"},"MessagePack"))),(0,r.kt)("h2",{id:"next-step"},"Next step"),(0,r.kt)("p",null,"Once you parsed the ",(0,r.kt)("inlineCode",{parentName:"p"},"Payload37"),", you should use the information in the payload to decrypt the message."),(0,r.kt)("p",null,"Once the message is decrypted, you should parse the message by ",(0,r.kt)("a",{parentName:"p",href:"/docs/payload-format/typed-message"},"the TypedMessage spec"),"."),(0,r.kt)("h2",{id:"faq"},"FAQ"),(0,r.kt)("h3",{id:"why-the-version-number-is-negative"},"Why the version number is negative?"),(0,r.kt)("p",null,"The pre 1.0 version of the Mask Network extension uses ",(0,r.kt)("inlineCode",{parentName:"p"},"-42")," as its initial payload version. The number ",(0,r.kt)("inlineCode",{parentName:"p"},"42")," comes from the book ",(0,r.kt)("em",{parentName:"p"},"The Hitchhiker's Guide to the Galaxy")," and the minus sign indicates this is an early version. When a new payload format is drafted, it's a natural idea that the version number should add by 1, therefore it should be ",(0,r.kt)("inlineCode",{parentName:"p"},"-41"),". At the time of this spec written, the latest payload is version ",(0,r.kt)("inlineCode",{parentName:"p"},"-38"),", therefore this spec follows the convention to mark the version as ",(0,r.kt)("inlineCode",{parentName:"p"},"-37"),"."))}h.isMDXComponent=!0}}]);