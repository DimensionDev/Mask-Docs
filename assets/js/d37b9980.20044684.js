"use strict";(self.webpackChunkmask_docs=self.webpackChunkmask_docs||[]).push([[487],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||r;return n?a.createElement(h,i(i({ref:t},d),{},{components:n})):a.createElement(h,i({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<r;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5592:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return l},default:function(){return m},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return p}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],s={title:"Hooks",sidebar_position:1},l=void 0,c={unversionedId:"web3/hooks",id:"web3/hooks",title:"Hooks",description:'In Mask Network, a special kind of plugin provides the abilities of a network; they are "Network Plugins". Each of them has a unique ID. An enum called NetworkPlugin lists them all in it.',source:"@site/docs/web3/hooks.md",sourceDirName:"web3",slug:"/web3/hooks",permalink:"/docs/web3/hooks",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/web3/hooks.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Hooks",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Types",permalink:"/docs/web3/types"},next:{title:"States",permalink:"/docs/web3/state"}},d={},p=[{value:"<code>&lt;NetworkContextProvider /&gt;</code>",id:"networkcontextprovider-",level:3},{value:"<code>&lt;ChainContextProvider /&gt;</code>",id:"chaincontextprovider-",level:3},{value:"Web3 Hooks",id:"web3-hooks",level:3}],u={toc:p};function m(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'In Mask Network, a special kind of plugin provides the abilities of a network; they are "Network Plugins". Each of them has a unique ID. An ',(0,r.kt)("inlineCode",{parentName:"p"},"enum")," called ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPlugin")," lists them all in it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export enum NetworkPluginID {\n    PLUGIN_EVM = 'com.mask.evm',\n    PLUGIN_FLOW = 'com.mask.flow',\n    PLUGIN_SOLANA = 'com.mask.solana',\n    /* Add your new network plugin here. */\n}\n")),(0,r.kt)("p",null,"A network plugin will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"Web3State")," that encapsulates the network abilities. There are public shared ",(0,r.kt)("inlineCode",{parentName:"p"},"Web3State")," interfaces that every network plugin should implement by itself. It means that all networks have the same API exported for their consumers, conversely speaking, a consumer can support another network without a code change. The only thing is to change the ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPlugin")," to the expected one. It makes all networks use one set of hooks."),(0,r.kt)("p",null,"On the React UI side, UI components can access any network states with ",(0,r.kt)("strong",{parentName:"p"},"React hooks")," (In the future, we may provide callable APIs for React-free environment)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// access Web3 abilities of the EVM plugin\nconst Web3State = useWeb3State(NetworkPluginID.PLUGIN_EVM)\n\n// access Web3 abilities of the flow plugin\nconst Web3State = useWeb3State(NetworkPluginID.PLUGIN_FLOW)\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"As we know, all React hooks should write in a functional component. Here we omit the component wrapper for demonstrating the concept. In production, they should always stay in components."))),(0,r.kt)("h3",{id:"networkcontextprovider-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<NetworkContextProvider />")),(0,r.kt)("p",null,"In case a plugin only serves a specific network. The ",(0,r.kt)("inlineCode",{parentName:"p"},"<NetworkContextProvider />")," could be used to set a default ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPluginID"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"<NetworkContextProvider value={NetworkPluginID.PLUGIN_EVM}>\n    {/* EVM only plugin */}\n    <PluginComponent />\n</NetworkContextProvider>\n")),(0,r.kt)("p",null,"In the contexted component ",(0,r.kt)("inlineCode",{parentName:"p"},"<PluginComponent />"),", we don't have to use Web3 hooks with ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPluginID.PLUGIN_EVM")," anymore. It always reaches EVM data til another ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPluginID")," is given."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"function PluginComponent({ expectedPluginID }: { expectedPluginID: NetworkPluginID }) {\n    // the contexted plugin ID (read & write)\n    const { pluginID, setPluginID } = useNetworkContextProvider(expectedPluginID)\n\n    const onSwitchPluginID = (nextPluginID) => {\n        setPluginID(nextPluginID)\n    }\n}\n")),(0,r.kt)("h3",{id:"chaincontextprovider-"},(0,r.kt)("inlineCode",{parentName:"h3"},"<ChainContextProvider />")),(0,r.kt)("p",null,"Sometimes, a plugin may need to ignore the global state changes. E.g., to implement a UI to only reveal information under a specific subnetwork without really switching to it."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"<ChainContextProvider />")," comes to helper. We can specify a plugin-controlled ",(0,r.kt)("inlineCode",{parentName:"p"},"chainId")," with it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function PluginComponent({ expectedChainId }: { expectedChainId: ChainId }) {\n    return (\n        <ChainContextProvider value={{ chainId: expectedChainId }}>\n            <Component />\n        </<ChainContextProvider>\n    )\n}\n")),(0,r.kt)("p",null,"In the contexted component ",(0,r.kt)("inlineCode",{parentName:"p"},"<Component />"),", we use ",(0,r.kt)("inlineCode",{parentName:"p"},"useChainId()")," to access the global chain ID, at the same time, the contexted chain ID as well accessable with ",(0,r.kt)("inlineCode",{parentName:"p"},"useChainContextProvider()")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-tsx"},"function Component() {\n    // the global chain id (readonly)\n    const globalChainId = useChainId()\n\n    // the contexted chain id (read & write)\n    const { chainId, setChainId }= useChainContextProvider()\n\n    const onSwitchChainId = (nextChainId) => {\n        setChaniId(nextChainId)\n    }\n}\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Not only for chain ID, but also the ",(0,r.kt)("inlineCode",{parentName:"p"},"<ChainContextProvider />")," supports to set context account, provider type, and, network type."))),(0,r.kt)("h3",{id:"web3-hooks"},"Web3 Hooks"),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Web3State")," contains all stuff a network should have. We defined many interfaces that a network plugin suppose to implement. But they are not mandatory. A network plugin can implement the state only if it supports a specific feature. E.g., if a network may lack facilities like ENS on Ethereum, it can choose not to implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"NameService")," state. Because of that, some features of Mask Network which depend on that interface will not work."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { NameService } = useWeb3State(NetworkPluginID.PLUGIN_ID)\n\nconst { value: name = 'UNKNOWN' } = useAsync(async () => {\n    // the NameService could be undefined, it's not mandatory for every network to implement\n    return NameService?.lookup(address) \n})\n")),(0,r.kt)("p",null,"Always access state from the start of ",(0,r.kt)("inlineCode",{parentName:"p"},"useWeb3State()")," is boring and lengthy. Since then, there have been a bunch of hooks existed to reduce labor work. Here is a simplified version of the previous one."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const { value: name = 'UNKNOWN' } = useLookupAddress(NetwrokPluginID.PLUGIN_ID, address)\n")),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"All Web3 hooks reserved the first parameter for ",(0,r.kt)("inlineCode",{parentName:"p"},"NetworkPluginID"),". It's omittable if the rest parameters are not necessary. It will take the plugin ID of the currently selected network as a fallback. What's more, we can use ",(0,r.kt)("inlineCode",{parentName:"p"},"PluginIDContextProvider")," to override this behavior."))),(0,r.kt)("p",null,"As we know, the extension maintains three kinds of pages. It includes a background page, some extension pages (popups and dashboard), and multiple content pages. Yeah, each of them will create a ",(0,r.kt)("inlineCode",{parentName:"p"},"PluginsWeb3Context"),". And they are sharing the same copy of data. If we alter the state of the context on the content page, it will finally sync to the rest pages. These UI components can update automatically, although they stay on different pages."),(0,r.kt)("p",null,"Suppose we have an address book UI running on the content page. The user could add a new address to the book by clicking somewhere on it."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const account = useAccount(NetworkPluginID.PLUGIN_ID)\nconst { AddressBook } = useWeb3State(NetworkPluginID.PLUGIN_ID)\n\nconst onAddAddress = useCallback(async (address: string) => {\n    // add a new address into the AddressBook state\n    await AddressBook?.addAddress(account, addresss)\n})\n")),(0,r.kt)("p",null,"And a select box on the options page will react to changes from the content page."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const account = useAccount(NetworkPluginID.PLUGIN_ID)\n\n// the address book will change if the user adds an address on the content page.\nconst addressBook = useAddressBook(NetworkPluginID.PLUGIN_ID, account)\n\nreturn <AddressSelectBox addressBook={address} />\n")))}m.isMDXComponent=!0}}]);