"use strict";(self.webpackChunkmask_docs=self.webpackChunkmask_docs||[]).push([[587],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=r,k=d["".concat(s,".").concat(m)]||d[m]||u[m]||o;return n?a.createElement(k,i(i({ref:t},p),{},{components:n})):a.createElement(k,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},7249:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return s},default:function(){return m},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return u}});var a=n(7462),r=n(3366),o=(n(7294),n(3905)),i=["components"],l={},s="Wallet Integration",c={unversionedId:"guide/wallet-integration",id:"guide/wallet-integration",title:"Wallet Integration",description:"Any wallet available in a browser environment can integrate into Mask Network. Well know wallets like MetaMask, WalletConnect and Fortmatic have already been integrated. Besides that, Mask Network is also able to host accounts by itself.",source:"@site/docs/guide/wallet-integration.md",sourceDirName:"guide",slug:"/guide/wallet-integration",permalink:"/docs/guide/wallet-integration",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/wallet-integration.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Internationalization",permalink:"/docs/guide/internationalization"},next:{title:"Payload Format",permalink:"/docs/category/payload-format"}},p={},u=[{value:"Overview",id:"overview",level:2},{value:"A Wallet on a bridged provider",id:"a-wallet-on-a-bridged-provider",level:2},{value:"A wallet without any UI",id:"a-wallet-without-any-ui",level:2},{value:"Interceptor",id:"interceptor",level:2},{value:"Examples",id:"examples",level:2}],d={toc:u};function m(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"wallet-integration"},"Wallet Integration"),(0,o.kt)("p",null,"Any wallet available in a browser environment can integrate into Mask Network. Well know wallets like ",(0,o.kt)("a",{parentName:"p",href:"https://metamask.io/"},"MetaMask"),", ",(0,o.kt)("a",{parentName:"p",href:"https://docs.walletconnect.com/"},"WalletConnect")," and ",(0,o.kt)("a",{parentName:"p",href:"https://fortmatic.com/"},"Fortmatic")," have already been integrated. Besides that, Mask Network is also able to host accounts by itself."),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-txt"},"   Front End Page                                 Background Page\n+------------------+                            +-----------------+\n|       User       | - Messaging API ---------- |  RPC Composer   |\n+------------------+                            +-----------------+\n                                                |                 |\n+------------------+                   +-----------------+   +-----------------+\n| Bridge Component | - Event Emitter-- |  Other Wallets  |   |   Mask Wallet   |\n+------------------+                   +-----------------+   +-----------------+\n         |                                                            |\n+------------------+                                                  |\n|    Wallet SDK    |                                                  |\n+------------------+                                                  |\n         |                                                            |\n         +------------------------- Network --------------------------+\n")),(0,o.kt)("p",null,"Above is an architecture overview illustrating how Mask Network integrates multiple wallets simultaneously. Roughly speaking, it includes two parts: the bridge component on the front end, and the JSON-RPC composer on the background end. They communicate with each other by leveraging the ",(0,o.kt)("a",{parentName:"p",href:"https://developer.chrome.com/docs/extensions/mv3/messaging/"},"Messaging Passing API"),"."),(0,o.kt)("p",null,"As a quick example to let you know how all stuff spins. Here is a UI button that will emit an ",(0,o.kt)("inlineCode",{parentName:"p"},"eth_getBlockNumber")," request once it is clicked."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-tsx"},"import { useWeb3 } from '@masknet/web3-shared-evm'\n\nfunction Example() {\n  const web3 = useWeb3()\n  const onClick = useCallback(async () => {\n    const blockNumber = await web3.eth.getBlockNumber()\n    console.log(`The current block number is ${blockNumber}.`)\n  }, [web3])\n  return <button onClick={onClick}>Get Block Number</button>\n}\n")),(0,o.kt)("p",null,"First of all, it creates a ",(0,o.kt)("a",{parentName:"p",href:"https://web3js.readthedocs.io/"},"Web3")," instance which redirects all JSON-RPC requests to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/request.ts"},"request")," service on the background page. If you'd like to read the source code, you will realise that there is a ",(0,o.kt)("a",{parentName:"p",href:"https://koajs.com/"},"Koa.js")," styled ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/koajs/compose"},"composer")," built-in. A list of middleware is used and serve different purposes: a middleware stores transactions into DB, a middleware watches transaction status, a middleware notifies transaction progress, and so on."),(0,o.kt)("p",null,"At the current stage, there are two kinds of wallets: Mask Wallet and other wallets."),(0,o.kt)("p",null,"Mask Wallet sends requests to the network directly on the background page. If the request takes the response, then the user will get notified."),(0,o.kt)("p",null,"But it's not that simple for other wallets. They are supported only on the front end. E.g., the ",(0,o.kt)("a",{parentName:"p",href:"https://docs.fortmatic.com/"},"Fortmatic")," SDK injects an iframe on the currently visiting page. Mask Network cannot invoke those SDKs on the background page as an extension. Because of that, they should take their requests to the front end and handle them there. Many mounted components, so-called ",(0,o.kt)("inlineCode",{parentName:"p"},"ProviderBridge"),", listen to the ",(0,o.kt)("inlineCode",{parentName:"p"},"PROVIDER_RPC_REQUEST")," event and call the corresponding SDK once they receive any request from the background. After the SKD finishes the work, they return the result to the bridged provider on the background page with the ",(0,o.kt)("inlineCode",{parentName:"p"},"PROVIDER_RPC_RESPONSE")," event."),(0,o.kt)("p",null,"It takes a quite long detour, but the benefit is all requests can leverage Mask Wallet abilities."),(0,o.kt)("h2",{id:"a-wallet-on-a-bridged-provider"},"A Wallet on a bridged provider"),(0,o.kt)("p",null,"If the wallet that only works on the front end. It needs to use the bridged provider way."),(0,o.kt)("p",null,"On the front end:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"create a bridged provider by implementing the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/web3-shared/evm/types/index.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"EIP1193Provider"))," interface."),(0,o.kt)("li",{parentName:"ul"},"instantiate the bridged provider in ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/plugins/EVM/hooks/useBridgedProvider.ts"},"useBridgedProvider")," which was used by ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/plugins/EVM/UI/components/ProviderBridge.tsx"},(0,o.kt)("inlineCode",{parentName:"a"},"<ProviderBridge />")),"."),(0,o.kt)("li",{parentName:"ul"},"add a new ",(0,o.kt)("inlineCode",{parentName:"li"},"<ProviderBridge />")," in the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/plugins/EVM/UI/SNSAdaptor/index.tsx"},"EVM")," plugin to receive events from the background page.")),(0,o.kt)("p",null,"On the background page:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"instantiate a ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/providers/Bridged.ts"},"BridgedProvider")," and add it into the supported list in ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/provider.ts"},"getProvider"),".")),(0,o.kt)("h2",{id:"a-wallet-without-any-ui"},"A wallet without any UI"),(0,o.kt)("p",null,"If the wallet is totally UI free and can connect/disconnect by calling some APIs. It can send requests to those APIs directly."),(0,o.kt)("p",null,"On the background page:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"create a provider to extend from the ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/providers/MaskWallet.ts"},"BaseProvider")," interface and add it into the supported list in ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/provider.ts"},"getProvider"),".")),(0,o.kt)("h2",{id:"interceptor"},"Interceptor"),(0,o.kt)("p",null,"The implementation of Ethereum JSON-RPC may very different between wallets. Those JSON-RPC requests will need some preprocessing before sending to the real wallet. Nevertheless, the Mask Network flavors a bunch of self-known RPC methods that were unknown to other wallets. Bypassing a such request will hit an unimplemented error."),(0,o.kt)("p",null,"For this sake, the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/DimensionDev/Maskbook/blob/develop/packages/mask/src/extension/background-script/EthereumServices/composer.ts"},(0,o.kt)("inlineCode",{parentName:"a"},"composer"))," creates a middleware for intercepting JSON-RPC requests. Here is a quick example that converts the Mask Network flavored ",(0,o.kt)("a",{parentName:"p",href:"/docs/mask-flavored-jsonrpc-api#mask_requestaccounts"},(0,o.kt)("inlineCode",{parentName:"a"},"mask_requestAccounts"))," into an Ethereum styled ",(0,o.kt)("a",{parentName:"p",href:"https://eth.wiki/json-rpc/API#eth_accounts"},(0,o.kt)("inlineCode",{parentName:"a"},"eth_accounts")),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"export class Example implements Middleware<Context> {\n  async fn(context: Context, next: () => Promise<void>) {\n    switch (context.method) {\n      case EthereumMethodType.MASK_REQUEST_ACCOUNTS:\n        context.requestArguments = {\n          ...context.requestArguments,\n          method: EthereumMethodType.ETH_ACCOUNTS,\n        }\n        break\n      default:\n        break\n    }\n    await next()\n  }\n}\n")),(0,o.kt)("h2",{id:"examples"},"Examples"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Wallet"),(0,o.kt)("th",{parentName:"tr",align:null},"Implementation"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"MetaMask"),(0,o.kt)("td",{parentName:"tr",align:null},"-")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"WalletConnect"),(0,o.kt)("td",{parentName:"tr",align:null},"-")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"Fortmatic"),(0,o.kt)("td",{parentName:"tr",align:null},"-")))))}m.isMDXComponent=!0}}]);